#include <cmath>
#include <cstring>
#include <fstream>
#include <format>
#include <set>
#include <sstream>
#include <vector>
#include <string>

#include <DynamicOutput/Output.hpp>
#include <Mod/CppUserModBase.hpp>
#include <Unreal/UObjectGlobals.hpp>
#include <Unreal/UObject.hpp>
#include <Unreal/UFunction.hpp>
#include <Unreal/UClass.hpp>
#include <Unreal/FProperty.hpp>
#include <Unreal/UScriptStruct.hpp>
#include <Unreal/UStruct.hpp>
#include <Unreal/AActor.hpp>
#include <Unreal/FWeakObjectPtr.hpp>
#include <Unreal/NameTypes.hpp>
#include <Unreal/FString.hpp>
#include <Unreal/FText.hpp>

namespace MoriaMods
{
    using namespace RC;
    using namespace RC::Unreal;

    static constexpr float MY_PI = 3.14159265358979323846f;
    static constexpr float DEG2RAD = MY_PI / 180.0f;
    static constexpr float TRACE_DIST = 5000.0f;          // 50m (was 500m — way too far)
    static constexpr float POS_TOLERANCE = 100.0f;   // 1 meter — game scale is huge (walls = 2000 units)
    static constexpr int   STREAM_CHECK_INTERVAL = 180;

    // ── Raw UE4.27 types (floats, not doubles) ──
    struct FVec3f { float X, Y, Z; };
    struct FQuat4f { float X, Y, Z, W; };
    struct FRotator3f { float Pitch, Yaw, Roll; };

    struct FTransformRaw {
        FQuat4f  Rotation;
        FVec3f   Translation;
        float    _pad1{0};
        FVec3f   Scale3D;
        float    _pad2{0};
    };
    static_assert(sizeof(FTransformRaw) == 48, "FTransformRaw must be 48 bytes");

    // ── ProcessEvent param structs (layouts confirmed by probe) ──
    struct GetInstanceCount_Params { int32_t ReturnValue{0}; };

    #pragma pack(push, 1)
    struct GetInstanceTransform_Params {
        int32_t InstanceIndex{0};
        uint8_t _pad0[12]{};
        FTransformRaw OutTransform{};
        uint8_t bWorldSpace{1};
        uint8_t ReturnValue{0};
    };
    #pragma pack(pop)
    static_assert(sizeof(GetInstanceTransform_Params) == 66, "Must be 66 bytes");

    // FHitResult offsets (136 bytes, probed)
    namespace HitOff {
        constexpr int ImpactPoint = 24;
        constexpr int Item = 88;
        constexpr int bBlockingHit = 93;
        constexpr int Component = 112;   // FWeakObjectPtr (8 bytes)
    }

    // LineTraceSingle param offsets (237 bytes, probed)
    namespace LTOff {
        constexpr int WorldContextObject = 0;
        constexpr int Start = 8;
        constexpr int End = 20;
        constexpr int TraceChannel = 32;
        constexpr int bTraceComplex = 33;
        constexpr int ActorsToIgnore = 40;
        constexpr int DrawDebugType = 56;
        constexpr int OutHit = 60;
        constexpr int bIgnoreSelf = 196;
        constexpr int TraceColor = 200;
        constexpr int TraceHitColor = 216;
        constexpr int DrawTime = 232;
        constexpr int ReturnValue = 236;
        constexpr int ParmsSize = 237;
    }

    // ── Saved removal record ──
    struct SavedRemoval {
        std::string meshName;
        float posX, posY, posZ;
    };

    struct RemovedInstance {
        UObject* component;
        int32_t instanceIndex{-1};
        FTransformRaw transform;
        std::wstring componentName;
        bool isTypeRule{false};
        std::string typeRuleMeshId;
    };

    // PrintString param offsets (discovered at runtime via probe)
    struct PSOffsets {
        int worldContext{-1};
        int inString{-1};
        int printToScreen{-1};
        int printToLog{-1};
        int textColor{-1};
        int duration{-1};
        int parmsSize{0};
        bool valid{false};
    };

    class MoriaCppMod : public RC::CppUserModBase {
    private:
        std::vector<RemovedInstance> m_undoStack;
        std::vector<SavedRemoval> m_savedRemovals;
        std::set<std::string> m_typeRemovals;       // mesh IDs to remove ALL of (Num6)
        std::set<UObject*> m_processedComps;
        int m_frameCounter{0};
        bool m_replayActive{false};
        bool m_characterLoaded{false};
        int m_charLoadFrame{0};              // frame when character was first detected
        bool m_initialReplayDone{false};
        int m_stuckLogCount{0};              // only log stuck entries once
        std::string m_saveFilePath;
        PSOffsets m_ps;
        UObject* m_chatWidget{nullptr};
        UObject* m_sysMessages{nullptr};
        std::vector<bool> m_appliedRemovals;    // parallel to m_savedRemovals: true = already removed
        int m_rescanCounter{0};                 // frames since last full rescan

        // Throttled replay: spread UpdateInstanceTransform across frames to avoid
        // crashing the render thread (FStaticMeshInstanceBuffer::UpdateFromCommandBuffer_Concurrent)
        struct ReplayState {
            std::vector<UObject*> compQueue;
            size_t compIdx{0};
            int instanceIdx{0};       // resume position within current component
            bool active{false};
            int totalHidden{0};
        };
        ReplayState m_replay;
        static constexpr int MAX_HIDES_PER_FRAME = 3;  // conservative limit

        // ── Tracking helpers ──

        bool hasPendingRemovals() const
        {
            for (size_t i = 0; i < m_appliedRemovals.size(); i++) {
                if (!m_appliedRemovals[i]) return true;
            }
            return false;
        }

        int pendingCount() const
        {
            int n = 0;
            for (size_t i = 0; i < m_appliedRemovals.size(); i++) {
                if (!m_appliedRemovals[i]) n++;
            }
            return n;
        }

        // ── File I/O ──

        static std::string componentNameToMeshId(const std::wstring& name)
        {
            std::string narrow;
            narrow.reserve(name.size());
            for (wchar_t c : name) narrow.push_back(static_cast<char>(c));
            auto lastUnderscore = narrow.rfind('_');
            if (lastUnderscore != std::string::npos) {
                bool allDigits = true;
                for (size_t i = lastUnderscore + 1; i < narrow.size(); i++) {
                    if (!std::isdigit(narrow[i])) { allDigits = false; break; }
                }
                if (allDigits && lastUnderscore > 0) {
                    return narrow.substr(0, lastUnderscore);
                }
            }
            return narrow;
        }

        void loadSaveFile()
        {
            m_savedRemovals.clear();
            m_typeRemovals.clear();
            std::ifstream file(m_saveFilePath);
            if (!file.is_open()) {
                Output::send<LogLevel::Warning>(STR("[MoriaCppMod] No save file found (first run)\n"));
                return;
            }
            std::string line;
            while (std::getline(file, line)) {
                if (line.empty() || line[0] == '#') continue;
                // @meshName = type rule (remove ALL of this mesh)
                if (line[0] == '@') {
                    m_typeRemovals.insert(line.substr(1));
                    continue;
                }
                std::istringstream ss(line);
                SavedRemoval sr;
                std::string token;
                if (!std::getline(ss, sr.meshName, '|')) continue;
                if (!std::getline(ss, token, '|')) continue; sr.posX = std::stof(token);
                if (!std::getline(ss, token, '|')) continue; sr.posY = std::stof(token);
                if (!std::getline(ss, token, '|')) continue; sr.posZ = std::stof(token);
                m_savedRemovals.push_back(sr);
            }

            // Remove position entries that are redundant with type rules
            {
                size_t before = m_savedRemovals.size();
                std::erase_if(m_savedRemovals, [this](const SavedRemoval& sr) {
                    return m_typeRemovals.count(sr.meshName) > 0;
                });
                size_t redundant = before - m_savedRemovals.size();
                if (redundant > 0) {
                    Output::send<LogLevel::Warning>(
                        STR("[MoriaCppMod] Removed {} position entries redundant with type rules\n"), redundant);
                }
            }

            // No dedup — stacked instances share the same position,
            // and each entry matches a different stacked instance on replay

            // Initialize tracking: all pending (not yet applied)
            m_appliedRemovals.assign(m_savedRemovals.size(), false);

            Output::send<LogLevel::Warning>(
                STR("[MoriaCppMod] Loaded {} position removals + {} type rules\n"),
                m_savedRemovals.size(), m_typeRemovals.size());
        }

        void appendToSaveFile(const SavedRemoval& sr)
        {
            std::ofstream file(m_saveFilePath, std::ios::app);
            if (!file.is_open()) return;
            file << sr.meshName << "|" << sr.posX << "|" << sr.posY << "|" << sr.posZ << "\n";
        }

        void rewriteSaveFile()
        {
            std::ofstream file(m_saveFilePath, std::ios::trunc);
            if (!file.is_open()) return;
            file << "# MoriaCppMod removed instances\n";
            file << "# meshName|posX|posY|posZ = single instance\n";
            file << "# @meshName = remove ALL of this type\n";
            for (auto& type : m_typeRemovals)
                file << "@" << type << "\n";
            for (auto& sr : m_savedRemovals)
                file << sr.meshName << "|" << sr.posX << "|" << sr.posY << "|" << sr.posZ << "\n";
        }

        // ── Helpers ──

        UObject* findPlayerController()
        {
            std::vector<UObject*> pcs;
            UObjectGlobals::FindAllOf(STR("PlayerController"), pcs);
            return pcs.empty() ? nullptr : pcs[0];
        }

        UObject* getPawn()
        {
            auto* pc = findPlayerController();
            if (!pc) return nullptr;
            auto* fn = pc->GetFunctionByNameInChain(STR("K2_GetPawn"));
            if (!fn) return nullptr;
            struct { UObject* Ret{nullptr}; } p{};
            pc->ProcessEvent(fn, &p);
            return p.Ret;
        }

        FVec3f getPawnLocation()
        {
            FVec3f loc{0, 0, 0};
            auto* pawn = getPawn();
            if (!pawn) return loc;
            auto* fn = pawn->GetFunctionByNameInChain(STR("K2_GetActorLocation"));
            if (!fn) return loc;
            pawn->ProcessEvent(fn, &loc);
            return loc;
        }

        // ── PrintString support ──

        void probePrintString()
        {
            auto* fn = UObjectGlobals::StaticFindObject<UFunction*>(
                nullptr, nullptr, STR("/Script/Engine.KismetSystemLibrary:PrintString"));
            if (!fn) {
                Output::send<LogLevel::Warning>(STR("[MoriaCppMod] PrintString NOT FOUND\n"));
                return;
            }
            m_ps.parmsSize = fn->GetParmsSize();
            Output::send<LogLevel::Warning>(STR("[MoriaCppMod] PrintString ParmsSize={}\n"), m_ps.parmsSize);

            for (auto* prop : fn->ForEachProperty()) {
                auto name = prop->GetName();
                int offset = prop->GetOffset_Internal();
                int size = prop->GetSize();
                Output::send<LogLevel::Warning>(
                    STR("[MoriaCppMod]   PS: {} @{} size={}\n"), name, offset, size);

                if (name == STR("WorldContextObject")) m_ps.worldContext = offset;
                else if (name == STR("inString"))       m_ps.inString = offset;
                else if (name == STR("bPrintToScreen")) m_ps.printToScreen = offset;
                else if (name == STR("bPrintToLog"))    m_ps.printToLog = offset;
                else if (name == STR("TextColor"))      m_ps.textColor = offset;
                else if (name == STR("Duration"))       m_ps.duration = offset;
            }

            m_ps.valid = (m_ps.worldContext >= 0 && m_ps.inString >= 0 &&
                          m_ps.printToScreen >= 0 && m_ps.duration >= 0);
            Output::send<LogLevel::Warning>(STR("[MoriaCppMod] PrintString valid={}\n"), m_ps.valid);
        }

        void showOnScreen(const std::wstring& text, float duration = 5.0f,
                         float r = 0.0f, float g = 1.0f, float b = 0.5f)
        {
            if (!m_ps.valid) return;

            auto* fn = UObjectGlobals::StaticFindObject<UFunction*>(
                nullptr, nullptr, STR("/Script/Engine.KismetSystemLibrary:PrintString"));
            auto* cdo = UObjectGlobals::StaticFindObject<UObject*>(
                nullptr, nullptr, STR("/Script/Engine.Default__KismetSystemLibrary"));
            auto* pc = findPlayerController();
            if (!fn || !cdo || !pc) return;

            std::vector<uint8_t> buf(m_ps.parmsSize, 0);

            // WorldContextObject
            std::memcpy(buf.data() + m_ps.worldContext, &pc, 8);

            // FString in param buffer: Data ptr (8) + ArrayNum (4) + ArrayMax (4)
            const wchar_t* textPtr = text.c_str();
            int32_t len = static_cast<int32_t>(text.size() + 1);
            uintptr_t ptrVal = reinterpret_cast<uintptr_t>(textPtr);
            std::memcpy(buf.data() + m_ps.inString, &ptrVal, 8);
            std::memcpy(buf.data() + m_ps.inString + 8, &len, 4);
            std::memcpy(buf.data() + m_ps.inString + 12, &len, 4);

            // bPrintToScreen = true
            buf[m_ps.printToScreen] = 1;

            // bPrintToLog = false (don't spam log)
            if (m_ps.printToLog >= 0) buf[m_ps.printToLog] = 0;

            // TextColor (FLinearColor: R, G, B, A)
            if (m_ps.textColor >= 0) {
                float color[4] = {r, g, b, 1.0f};
                std::memcpy(buf.data() + m_ps.textColor, color, 16);
            }

            // Duration
            std::memcpy(buf.data() + m_ps.duration, &duration, 4);

            cdo->ProcessEvent(fn, buf.data());
        }

        // ── Chat/Widget display ──

        void findWidgets()
        {
            std::vector<UObject*> widgets;
            UObjectGlobals::FindAllOf(STR("UserWidget"), widgets);
            m_chatWidget = nullptr;
            m_sysMessages = nullptr;
            for (auto* w : widgets) {
                std::wstring clsName(w->GetClassPrivate()->GetName());
                if (clsName == STR("WBP_UI_ChatWidget_C") && !m_chatWidget)
                    m_chatWidget = w;
                if (clsName == STR("WBP_UI_Console_SystemMessages_C") && !m_sysMessages)
                    m_sysMessages = w;
            }
        }

        void showGameMessage(const std::wstring& text)
        {
            if (!m_chatWidget) findWidgets();
            if (!m_chatWidget) return;

            // AddToShortChat(FText) — the floating chat overlay
            auto* func = m_chatWidget->GetFunctionByNameInChain(STR("AddToShortChat"));
            if (!func) {
                Output::send<LogLevel::Warning>(STR("[MoriaCppMod] AddToShortChat not found\n"));
                return;
            }

            FText ftext(text.c_str());
            uint8_t buf[64]{};
            std::memcpy(buf, &ftext, sizeof(FText));
            m_chatWidget->ProcessEvent(func, buf);
        }

        // ── Test all display methods (Num5) ──

        void testAllDisplayMethods()
        {
            Output::send<LogLevel::Warning>(STR("[MoriaCppMod] === Testing display methods ===\n"));
            findWidgets();

            if (m_chatWidget) {
                Output::send<LogLevel::Warning>(STR("[MoriaCppMod] ChatWidget found\n"));

                // Test 1: AddToShortChat
                auto* f1 = m_chatWidget->GetFunctionByNameInChain(STR("AddToShortChat"));
                if (f1) {
                    FText t1(STR("[Mod] Test 1: AddToShortChat"));
                    uint8_t buf[64]{};
                    std::memcpy(buf, &t1, sizeof(FText));
                    m_chatWidget->ProcessEvent(f1, buf);
                    Output::send<LogLevel::Warning>(STR("[MoriaCppMod] Called AddToShortChat\n"));
                }

                // Test 2: SystemMessageEvent
                auto* f2 = m_chatWidget->GetFunctionByNameInChain(STR("SystemMessageEvent"));
                if (f2) {
                    FText t2(STR("[Mod] Test 2: SystemMessageEvent"));
                    uint8_t buf[64]{};
                    std::memcpy(buf, &t2, sizeof(FText));
                    m_chatWidget->ProcessEvent(f2, buf);
                    Output::send<LogLevel::Warning>(STR("[MoriaCppMod] Called SystemMessageEvent\n"));
                }

                // Test 3: AddFormattedMessage
                auto* f3 = m_chatWidget->GetFunctionByNameInChain(STR("AddFormattedMessage"));
                if (f3) {
                    FText t3(STR("[Mod] Test 3: AddFormattedMessage"));
                    uint8_t buf[64]{};
                    std::memcpy(buf, &t3, sizeof(FText));
                    m_chatWidget->ProcessEvent(f3, buf);
                    Output::send<LogLevel::Warning>(STR("[MoriaCppMod] Called AddFormattedMessage\n"));
                }
            } else {
                Output::send<LogLevel::Warning>(STR("[MoriaCppMod] ChatWidget NOT found\n"));
            }

            if (m_sysMessages) {
                Output::send<LogLevel::Warning>(STR("[MoriaCppMod] SystemMessages found\n"));

                // Test 4: AppendMessage
                auto* f4 = m_sysMessages->GetFunctionByNameInChain(STR("AppendMessage"));
                if (f4) {
                    FText t4(STR("[Mod] Test 4: AppendMessage"));
                    uint8_t buf[64]{};
                    std::memcpy(buf, &t4, sizeof(FText));
                    m_sysMessages->ProcessEvent(f4, buf);
                    Output::send<LogLevel::Warning>(STR("[MoriaCppMod] Called AppendMessage\n"));
                }
            } else {
                Output::send<LogLevel::Warning>(STR("[MoriaCppMod] SystemMessages NOT found\n"));
            }

            Output::send<LogLevel::Warning>(STR("[MoriaCppMod] === Display test done ===\n"));
        }

        // ── Camera & Trace ──

        bool getCameraRay(FVec3f& outStart, FVec3f& outEnd)
        {
            auto* pc = findPlayerController();
            if (!pc) return false;

            // Get viewport size
            auto* vpFunc = pc->GetFunctionByNameInChain(STR("GetViewportSize"));
            if (!vpFunc) return false;
            struct { int32_t SizeX{0}, SizeY{0}; } vpParams{};
            pc->ProcessEvent(vpFunc, &vpParams);
            float centerX = vpParams.SizeX / 2.0f;
            float centerY = vpParams.SizeY / 2.0f;

            // Deproject screen center to world ray
            auto* deprojFunc = pc->GetFunctionByNameInChain(STR("DeprojectScreenPositionToWorld"));
            if (!deprojFunc) return false;
            int parmsSize = deprojFunc->GetParmsSize();
            std::vector<uint8_t> buf(parmsSize, 0);
            std::memcpy(buf.data() + 0, &centerX, 4);
            std::memcpy(buf.data() + 4, &centerY, 4);
            pc->ProcessEvent(deprojFunc, buf.data());

            FVec3f cameraLoc{}, worldDir{};
            std::memcpy(&cameraLoc, buf.data() + 8, 12);
            std::memcpy(&worldDir, buf.data() + 20, 12);

            // 3rd-person fix: start trace PAST the character to avoid hitting
            // objects between the camera and the player (the "behind me" problem)
            FVec3f pawnLoc = getPawnLocation();
            float dx = pawnLoc.X - cameraLoc.X;
            float dy = pawnLoc.Y - cameraLoc.Y;
            float dz = pawnLoc.Z - cameraLoc.Z;
            float camToChar = std::sqrt(dx*dx + dy*dy + dz*dz);
            float startOffset = camToChar + 50.0f; // 50 units past the character

            outStart = {
                cameraLoc.X + worldDir.X * startOffset,
                cameraLoc.Y + worldDir.Y * startOffset,
                cameraLoc.Z + worldDir.Z * startOffset
            };
            outEnd = {
                cameraLoc.X + worldDir.X * TRACE_DIST,
                cameraLoc.Y + worldDir.Y * TRACE_DIST,
                cameraLoc.Z + worldDir.Z * TRACE_DIST
            };
            return true;
        }

        // Resolve hit component directly from FHitResult weak pointer
        UObject* resolveHitComponent(const uint8_t* hitBuf)
        {
            RC::Unreal::FWeakObjectPtr weakPtr{};
            std::memcpy(&weakPtr, hitBuf + HitOff::Component, sizeof(RC::Unreal::FWeakObjectPtr));
            return weakPtr.Get();
        }

        bool isHISMComponent(UObject* comp)
        {
            if (!comp) return false;
            auto* cls = comp->GetClassPrivate();
            if (!cls) return false;
            std::wstring clsName(cls->GetName());
            return clsName.find(STR("InstancedStaticMeshComponent")) != std::wstring::npos;
        }

        // Hide instance by moving underground + tiny scale (safe — no crash unlike RemoveInstance)
        bool hideInstance(UObject* comp, int32_t instanceIndex)
        {
            auto* updateFunc = comp->GetFunctionByNameInChain(STR("UpdateInstanceTransform"));
            if (!updateFunc) return false;

            // Get current transform first
            auto* transFunc = comp->GetFunctionByNameInChain(STR("GetInstanceTransform"));
            if (!transFunc) return false;
            GetInstanceTransform_Params gtp{};
            gtp.InstanceIndex = instanceIndex;
            gtp.bWorldSpace = 1;
            comp->ProcessEvent(transFunc, &gtp);
            if (!gtp.ReturnValue) return false;

            // Move deep underground, scale to near-zero
            FTransformRaw hidden = gtp.OutTransform;
            hidden.Translation.Z -= 50000.0f;
            hidden.Scale3D = {0.001f, 0.001f, 0.001f};

            // UpdateInstanceTransform(int32 Index, FTransform NewTrans, bool bWorldSpace,
            //                         bool bMarkRenderStateDirty, bool bTeleport) -> bool
            // Layout matches GetInstanceTransform + 2 extra bools
            uint8_t params[72]{};
            int32_t idx = instanceIndex;
            std::memcpy(params + 0, &idx, 4);          // InstanceIndex
            std::memcpy(params + 16, &hidden, 48);      // NewInstanceTransform (aligned)
            params[64] = 1;  // bWorldSpace
            params[65] = 1;  // bMarkRenderStateDirty
            params[66] = 1;  // bTeleport
            comp->ProcessEvent(updateFunc, params);
            return params[67] != 0;  // ReturnValue
        }

        // Restore instance to original transform (undo a hide)
        bool restoreInstance(UObject* comp, int32_t instanceIndex, const FTransformRaw& original)
        {
            auto* updateFunc = comp->GetFunctionByNameInChain(STR("UpdateInstanceTransform"));
            if (!updateFunc) return false;

            uint8_t params[72]{};
            std::memcpy(params + 0, &instanceIndex, 4);
            std::memcpy(params + 16, &original, 48);
            params[64] = 1;  // bWorldSpace
            params[65] = 1;  // bMarkRenderStateDirty
            params[66] = 1;  // bTeleport
            comp->ProcessEvent(updateFunc, params);
            return params[67] != 0;
        }

        bool doLineTrace(const FVec3f& start, const FVec3f& end, uint8_t* hitBuf,
                         bool debugDraw = false)
        {
            auto* ltFunc = UObjectGlobals::StaticFindObject<UFunction*>(
                nullptr, nullptr, STR("/Script/Engine.KismetSystemLibrary:LineTraceSingle"));
            auto* kslCDO = UObjectGlobals::StaticFindObject<UObject*>(
                nullptr, nullptr, STR("/Script/Engine.Default__KismetSystemLibrary"));
            auto* pc = findPlayerController();
            if (!ltFunc || !kslCDO || !pc) return false;

            uint8_t params[LTOff::ParmsSize]{};
            std::memcpy(params + LTOff::WorldContextObject, &pc, 8);
            std::memcpy(params + LTOff::Start, &start, 12);
            std::memcpy(params + LTOff::End, &end, 12);
            params[LTOff::TraceChannel] = 0;      // Visibility
            params[LTOff::bTraceComplex] = 1;      // Per-triangle for accuracy
            params[LTOff::bIgnoreSelf] = 1;

            // Add player pawn to ActorsToIgnore so trace doesn't hit the character
            auto* pawn = getPawn();
            if (pawn) {
                uintptr_t arrPtr = reinterpret_cast<uintptr_t>(&pawn);
                int32_t one = 1;
                std::memcpy(params + LTOff::ActorsToIgnore, &arrPtr, 8);
                std::memcpy(params + LTOff::ActorsToIgnore + 8, &one, 4);
                std::memcpy(params + LTOff::ActorsToIgnore + 12, &one, 4);
            }

            if (debugDraw) {
                params[LTOff::DrawDebugType] = 2;  // ForDuration
                float greenColor[4] = {0.0f, 1.0f, 0.0f, 1.0f};
                float redColor[4] = {1.0f, 0.0f, 0.0f, 1.0f};
                float drawTime = 5.0f;
                std::memcpy(params + LTOff::TraceColor, greenColor, 16);
                std::memcpy(params + LTOff::TraceHitColor, redColor, 16);
                std::memcpy(params + LTOff::DrawTime, &drawTime, 4);
            } else {
                params[LTOff::DrawDebugType] = 0;  // None
            }

            kslCDO->ProcessEvent(ltFunc, params);

            bool bHit = params[LTOff::ReturnValue] != 0;
            if (bHit) {
                std::memcpy(hitBuf, params + LTOff::OutHit, 136);
            }
            return bHit;
        }

        // ── Throttled Replay ──
        // Spreads UpdateInstanceTransform calls across frames to avoid crashing
        // the render thread (FStaticMeshInstanceBuffer::UpdateFromCommandBuffer_Concurrent).

        void startReplay()
        {
            if (m_replay.active) return;  // don't interrupt active replay
            m_replay = {};
            if (m_savedRemovals.empty() && m_typeRemovals.empty()) return;

            UObjectGlobals::FindAllOf(STR("GlobalHierarchicalInstancedStaticMeshComponent"), m_replay.compQueue);
            if (m_replay.compQueue.empty())
                UObjectGlobals::FindAllOf(STR("HierarchicalInstancedStaticMeshComponent"), m_replay.compQueue);

            m_replay.active = !m_replay.compQueue.empty();
            if (m_replay.active) {
                Output::send<LogLevel::Warning>(
                    STR("[MoriaCppMod] Starting throttled replay ({} comps, max {} hides/frame)\n"),
                    m_replay.compQueue.size(), MAX_HIDES_PER_FRAME);
            }
        }

        // Process up to MAX_HIDES_PER_FRAME instances per frame. Returns true if more work remains.
        bool processReplayBatch()
        {
            if (!m_replay.active) return false;

            int hidesThisBatch = 0;

            while (m_replay.compIdx < m_replay.compQueue.size()) {
                UObject* comp = m_replay.compQueue[m_replay.compIdx];

                // Validity check: can we access this component's functions?
                auto* countFunc = comp ? comp->GetFunctionByNameInChain(STR("GetInstanceCount")) : nullptr;
                if (!countFunc) {
                    m_replay.compIdx++;
                    m_replay.instanceIdx = 0;
                    continue;
                }

                std::string meshId = componentNameToMeshId(std::wstring(comp->GetName()));
                bool isTypeRule = m_typeRemovals.count(meshId) > 0;

                // For position-based, check if this mesh has any pending matches
                if (!isTypeRule) {
                    bool hasPending = false;
                    for (size_t si = 0; si < m_savedRemovals.size(); si++) {
                        if (!m_appliedRemovals[si] && m_savedRemovals[si].meshName == meshId) {
                            hasPending = true;
                            break;
                        }
                    }
                    if (!hasPending) {
                        m_processedComps.insert(comp);
                        m_replay.compIdx++;
                        m_replay.instanceIdx = 0;
                        continue;
                    }
                }

                auto* transFunc = comp->GetFunctionByNameInChain(STR("GetInstanceTransform"));

                // Get current instance count
                GetInstanceCount_Params cp{};
                comp->ProcessEvent(countFunc, &cp);
                int count = cp.ReturnValue;

                if (count == 0 || m_replay.instanceIdx >= count) {
                    m_processedComps.insert(comp);
                    m_replay.compIdx++;
                    m_replay.instanceIdx = 0;
                    continue;
                }

                // Process instances from where we left off
                while (m_replay.instanceIdx < count) {
                    if (hidesThisBatch >= MAX_HIDES_PER_FRAME) {
                        return true;  // Budget exhausted, continue next frame
                    }

                    int i = m_replay.instanceIdx++;

                    if (isTypeRule) {
                        // For type rules, skip already-hidden instances
                        if (transFunc) {
                            GetInstanceTransform_Params tp{};
                            tp.InstanceIndex = i;
                            tp.bWorldSpace = 1;
                            comp->ProcessEvent(transFunc, &tp);
                            if (tp.ReturnValue && tp.OutTransform.Translation.Z < -40000.0f)
                                continue;  // already hidden
                        }
                        if (hideInstance(comp, i)) {
                            hidesThisBatch++;
                            m_replay.totalHidden++;
                        }
                    } else if (transFunc) {
                        GetInstanceTransform_Params tp{};
                        tp.InstanceIndex = i;
                        tp.bWorldSpace = 1;
                        comp->ProcessEvent(transFunc, &tp);
                        if (!tp.ReturnValue) continue;

                        float px = tp.OutTransform.Translation.X;
                        float py = tp.OutTransform.Translation.Y;
                        float pz = tp.OutTransform.Translation.Z;
                        if (pz < -40000.0f) continue;  // already hidden

                        for (size_t si = 0; si < m_savedRemovals.size(); si++) {
                            if (m_appliedRemovals[si]) continue;
                            if (m_savedRemovals[si].meshName != meshId) continue;
                            float ddx = px - m_savedRemovals[si].posX;
                            float ddy = py - m_savedRemovals[si].posY;
                            float ddz = pz - m_savedRemovals[si].posZ;
                            if (ddx*ddx + ddy*ddy + ddz*ddz < POS_TOLERANCE * POS_TOLERANCE) {
                                hideInstance(comp, i);
                                m_appliedRemovals[si] = true;
                                hidesThisBatch++;
                                m_replay.totalHidden++;
                                break;
                            }
                        }
                    }
                }

                // Finished all instances in this component
                m_processedComps.insert(comp);
                m_replay.compIdx++;
                m_replay.instanceIdx = 0;
            }

            // All components processed — replay complete
            m_replay.active = false;
            int pending = pendingCount();
            Output::send<LogLevel::Warning>(
                STR("[MoriaCppMod] Replay done: {} hidden, {} pending\n"),
                m_replay.totalHidden, pending);
            return false;
        }

        void checkForNewComponents()
        {
            if (m_savedRemovals.empty() && m_typeRemovals.empty()) return;
            if (m_replay.active) return;  // don't interfere with active replay

            std::vector<UObject*> comps;
            UObjectGlobals::FindAllOf(STR("GlobalHierarchicalInstancedStaticMeshComponent"), comps);

            // Collect new (unprocessed) components
            std::vector<UObject*> newComps;
            for (auto* comp : comps) {
                if (!m_processedComps.count(comp))
                    newComps.push_back(comp);
            }
            if (newComps.empty()) return;

            // Queue them as a new replay batch
            m_replay = {};
            m_replay.compQueue = std::move(newComps);
            m_replay.active = true;
            Output::send<LogLevel::Warning>(
                STR("[MoriaCppMod] Streaming: {} new components queued for replay\n"),
                m_replay.compQueue.size());
        }

        // ── Actions ──

        void inspectAimed()
        {
            Output::send<LogLevel::Warning>(STR("[MoriaCppMod] --- Inspect ---\n"));

            FVec3f start{}, end{};
            if (!getCameraRay(start, end)) {
                Output::send<LogLevel::Warning>(STR("[MoriaCppMod] getCameraRay failed\n"));
                return;
            }

            Output::send<LogLevel::Warning>(
                STR("[MoriaCppMod] Ray: ({:.0f},{:.0f},{:.0f}) -> ({:.0f},{:.0f},{:.0f})\n"),
                start.X, start.Y, start.Z, end.X, end.Y, end.Z);

            uint8_t hitBuf[136]{};
            if (!doLineTrace(start, end, hitBuf, true)) {  // debugDraw=true
                Output::send<LogLevel::Warning>(STR("[MoriaCppMod] No hit\n"));
                showOnScreen(L"[Inspect] No hit", 3.0f, 1.0f, 0.3f, 0.3f);
                return;
            }

            FVec3f impactPoint;
            std::memcpy(&impactPoint, hitBuf + HitOff::ImpactPoint, 12);
            int32_t item;
            std::memcpy(&item, hitBuf + HitOff::Item, 4);

            // Resolve component directly via FWeakObjectPtr (fast, accurate)
            UObject* hitComp = resolveHitComponent(hitBuf);

            std::wstring compName = hitComp ? std::wstring(hitComp->GetName()) : L"(null)";
            std::wstring fullName = hitComp ? std::wstring(hitComp->GetFullName()) : L"(null)";
            std::wstring className = L"(unknown)";
            if (hitComp) {
                auto* cls = hitComp->GetClassPrivate();
                if (cls) className = std::wstring(cls->GetName());
            }
            bool isHISM = isHISMComponent(hitComp);
            std::string meshId = hitComp ? componentNameToMeshId(compName) : "(null)";
            std::wstring meshIdW(meshId.begin(), meshId.end());

            Output::send<LogLevel::Warning>(
                STR("[MoriaCppMod] Component: {} | Class: {} | Item: {} | HISM: {}\n"),
                compName, className, item, isHISM);
            Output::send<LogLevel::Warning>(
                STR("[MoriaCppMod] FullPath: {}\n"), fullName);
            Output::send<LogLevel::Warning>(
                STR("[MoriaCppMod] MeshID: {} | Impact: ({:.1f},{:.1f},{:.1f})\n"),
                meshIdW, impactPoint.X, impactPoint.Y, impactPoint.Z);

            // Show instance transform if it's an HISM
            if (isHISM && item >= 0 && hitComp) {
                auto* transFunc = hitComp->GetFunctionByNameInChain(STR("GetInstanceTransform"));
                if (transFunc) {
                    GetInstanceTransform_Params tp{};
                    tp.InstanceIndex = item;
                    tp.bWorldSpace = 1;
                    hitComp->ProcessEvent(transFunc, &tp);
                    if (tp.ReturnValue) {
                        Output::send<LogLevel::Warning>(
                            STR("[MoriaCppMod] Instance #{} pos: ({:.1f},{:.1f},{:.1f})\n"),
                            item, tp.OutTransform.Translation.X,
                            tp.OutTransform.Translation.Y, tp.OutTransform.Translation.Z);
                    }
                }
            }

            // On-screen display
            std::wstring screenText = fullName + L"\nClass: " + className;
            if (isHISM) {
                screenText += L"\nItem: " + std::to_wstring(item) + L" | MeshID: " + meshIdW;
            }
            float screenR = isHISM ? 0.0f : 1.0f;
            float screenG = isHISM ? 1.0f : 0.5f;
            showOnScreen(screenText, 8.0f, screenR, screenG, 0.5f);
        }

        void removeAimed()
        {
            FVec3f start{}, end{};
            if (!getCameraRay(start, end)) return;

            uint8_t hitBuf[136]{};
            if (!doLineTrace(start, end, hitBuf)) {
                Output::send<LogLevel::Warning>(STR("[MoriaCppMod] No hit\n"));
                showOnScreen(L"No hit", 2.0f, 1.0f, 0.3f, 0.3f);
                return;
            }

            FVec3f impactPoint;
            std::memcpy(&impactPoint, hitBuf + HitOff::ImpactPoint, 12);
            int32_t item;
            std::memcpy(&item, hitBuf + HitOff::Item, 4);

            // Resolve component directly
            UObject* hitComp = resolveHitComponent(hitBuf);

            if (!hitComp || !isHISMComponent(hitComp)) {
                std::wstring name = hitComp ? std::wstring(hitComp->GetName()) : L"(null)";
                std::wstring cls = L"";
                if (hitComp) {
                    auto* c = hitComp->GetClassPrivate();
                    if (c) cls = std::wstring(c->GetName());
                }
                Output::send<LogLevel::Warning>(
                    STR("[MoriaCppMod] Not HISM: {} ({})\n"), name, cls);
                showOnScreen(L"Not HISM: " + name, 3.0f, 1.0f, 0.5f, 0.0f);
                return;
            }

            if (item < 0) {
                Output::send<LogLevel::Warning>(STR("[MoriaCppMod] No instance index (Item=-1)\n"));
                showOnScreen(L"No instance index", 2.0f, 1.0f, 0.5f, 0.0f);
                return;
            }

            // Get transform of the aimed instance
            auto* transFunc = hitComp->GetFunctionByNameInChain(STR("GetInstanceTransform"));
            auto* countFunc = hitComp->GetFunctionByNameInChain(STR("GetInstanceCount"));
            if (!transFunc || !countFunc) return;
            GetInstanceTransform_Params tp{};
            tp.InstanceIndex = item;
            tp.bWorldSpace = 1;
            hitComp->ProcessEvent(transFunc, &tp);
            if (!tp.ReturnValue) return;

            float targetX = tp.OutTransform.Translation.X;
            float targetY = tp.OutTransform.Translation.Y;
            float targetZ = tp.OutTransform.Translation.Z;
            std::wstring compName(hitComp->GetName());
            std::string meshId = componentNameToMeshId(compName);

            // Find ALL instances at the same position (stacked instances)
            GetInstanceCount_Params cp{};
            hitComp->ProcessEvent(countFunc, &cp);
            int count = cp.ReturnValue;

            int hiddenCount = 0;
            for (int i = 0; i < count; i++) {
                GetInstanceTransform_Params itp{};
                itp.InstanceIndex = i;
                itp.bWorldSpace = 1;
                hitComp->ProcessEvent(transFunc, &itp);
                if (!itp.ReturnValue) continue;

                float px = itp.OutTransform.Translation.X;
                float py = itp.OutTransform.Translation.Y;
                float pz = itp.OutTransform.Translation.Z;

                // Skip already-hidden
                if (pz < -40000.0f) continue;

                float ddx = px - targetX;
                float ddy = py - targetY;
                float ddz = pz - targetZ;
                if (ddx*ddx + ddy*ddy + ddz*ddz < POS_TOLERANCE * POS_TOLERANCE) {
                    // Save for undo
                    m_undoStack.push_back({hitComp, i, itp.OutTransform, compName});

                    // Save to persistence file
                    SavedRemoval sr;
                    sr.meshName = meshId;
                    sr.posX = px;
                    sr.posY = py;
                    sr.posZ = pz;
                    m_savedRemovals.push_back(sr);
                    m_appliedRemovals.push_back(true);
                    appendToSaveFile(sr);

                    hideInstance(hitComp, i);
                    hiddenCount++;
                }
            }

            std::wstring meshIdW(meshId.begin(), meshId.end());
            Output::send<LogLevel::Warning>(
                STR("[MoriaCppMod] REMOVED {} stacked at ({:.0f},{:.0f},{:.0f}) from {} | Total: {}\n"),
                hiddenCount, targetX, targetY, targetZ, compName, m_savedRemovals.size());
            showOnScreen(L"REMOVED " + std::to_wstring(hiddenCount) + L"x: " + meshIdW, 3.0f, 0.0f, 1.0f, 0.0f);
            showGameMessage(L"[Mod] Removed " + std::to_wstring(hiddenCount) + L"x: " + meshIdW);
        }

        void removeAllOfType()
        {
            FVec3f start{}, end{};
            if (!getCameraRay(start, end)) return;

            uint8_t hitBuf[136]{};
            if (!doLineTrace(start, end, hitBuf)) {
                Output::send<LogLevel::Warning>(STR("[MoriaCppMod] No hit\n"));
                showOnScreen(L"No hit", 2.0f, 1.0f, 0.3f, 0.3f);
                return;
            }

            UObject* hitComp = resolveHitComponent(hitBuf);
            if (!hitComp || !isHISMComponent(hitComp)) {
                std::wstring name = hitComp ? std::wstring(hitComp->GetName()) : L"(null)";
                Output::send<LogLevel::Warning>(STR("[MoriaCppMod] Not HISM: {}\n"), name);
                showOnScreen(L"Not HISM: " + name, 3.0f, 1.0f, 0.5f, 0.0f);
                return;
            }

            auto* countFunc = hitComp->GetFunctionByNameInChain(STR("GetInstanceCount"));
            auto* transFunc = hitComp->GetFunctionByNameInChain(STR("GetInstanceTransform"));
            if (!countFunc) return;

            std::wstring compName(hitComp->GetName());
            std::string meshId = componentNameToMeshId(compName);

            // Save as type rule — removes ALL of this mesh on every world
            if (!m_typeRemovals.count(meshId)) {
                m_typeRemovals.insert(meshId);
                std::ofstream file(m_saveFilePath, std::ios::app);
                if (file.is_open()) file << "@" << meshId << "\n";
            }

            // Get instance count
            GetInstanceCount_Params cp{};
            hitComp->ProcessEvent(countFunc, &cp);
            int count = cp.ReturnValue;

            // Save all transforms for undo, then hide each instance
            int hidden = 0;
            for (int i = 0; i < count; i++) {
                if (transFunc) {
                    GetInstanceTransform_Params tp{};
                    tp.InstanceIndex = i;
                    tp.bWorldSpace = 1;
                    hitComp->ProcessEvent(transFunc, &tp);
                    if (tp.ReturnValue) {
                        // Skip already-hidden instances
                        if (tp.OutTransform.Translation.Z < -40000.0f) continue;
                        m_undoStack.push_back({hitComp, i, tp.OutTransform, compName, true, meshId});
                    }
                }
                if (hideInstance(hitComp, i)) hidden++;
            }

            std::wstring meshIdW(meshId.begin(), meshId.end());
            Output::send<LogLevel::Warning>(
                STR("[MoriaCppMod] TYPE RULE: @{} — hidden {} instances (persists across all worlds)\n"),
                meshIdW, hidden);
            showOnScreen(L"TYPE RULE: " + meshIdW + L" (" + std::to_wstring(hidden) + L" hidden)",
                         5.0f, 1.0f, 0.5f, 0.0f);
            showGameMessage(L"[Mod] Type rule: " + meshIdW + L" (" + std::to_wstring(hidden) + L" hidden)");
        }

        void undoLast()
        {
            if (m_undoStack.empty()) {
                Output::send<LogLevel::Warning>(STR("[MoriaCppMod] Nothing to undo\n"));
                showOnScreen(L"Nothing to undo", 2.0f, 1.0f, 0.5f, 0.0f);
                return;
            }

            auto& last = m_undoStack.back();

            // Type rule undo: restore all instances and remove the @rule
            if (last.isTypeRule) {
                std::string meshId = last.typeRuleMeshId;

                // Collect all undo entries for this type rule (they're contiguous at the back)
                std::vector<RemovedInstance> toRestore;
                while (!m_undoStack.empty()) {
                    auto& entry = m_undoStack.back();
                    if (!entry.isTypeRule || entry.typeRuleMeshId != meshId) break;
                    toRestore.push_back(entry);
                    m_undoStack.pop_back();
                }

                // Restore all instances (un-hide them by restoring original transform)
                int restored = 0;
                for (auto& ri : toRestore) {
                    if (restoreInstance(ri.component, ri.instanceIndex, ri.transform))
                        restored++;
                }

                // Remove the type rule
                m_typeRemovals.erase(meshId);
                rewriteSaveFile();

                std::wstring meshIdW(meshId.begin(), meshId.end());
                Output::send<LogLevel::Warning>(
                    STR("[MoriaCppMod] Undo type rule: {} — restored {} instances\n"),
                    meshIdW, restored);
                showOnScreen(L"Undo type: " + meshIdW + L" (" + std::to_wstring(restored) + L" restored)",
                            3.0f, 0.5f, 0.5f, 1.0f);
                return;
            }

            // Single instance undo
            std::string meshId = componentNameToMeshId(last.componentName);
            float px = last.transform.Translation.X;
            float py = last.transform.Translation.Y;
            float pz = last.transform.Translation.Z;

            for (size_t i = 0; i < m_savedRemovals.size(); i++) {
                if (m_savedRemovals[i].meshName == meshId) {
                    float ddx = m_savedRemovals[i].posX - px;
                    float ddy = m_savedRemovals[i].posY - py;
                    float ddz = m_savedRemovals[i].posZ - pz;
                    if (ddx*ddx + ddy*ddy + ddz*ddz < POS_TOLERANCE * POS_TOLERANCE) {
                        m_savedRemovals.erase(m_savedRemovals.begin() + i);
                        m_appliedRemovals.erase(m_appliedRemovals.begin() + i);
                        break;
                    }
                }
            }
            rewriteSaveFile();

            // Restore by un-hiding (set original transform back)
            bool ok = restoreInstance(last.component, last.instanceIndex, last.transform);
            Output::send<LogLevel::Warning>(
                STR("[MoriaCppMod] Restored index {} ({}) | {} remaining\n"),
                last.instanceIndex, ok ? STR("ok") : STR("FAILED"), m_savedRemovals.size());
            showOnScreen(L"Restored | " + std::to_wstring(m_savedRemovals.size()) + L" saved",
                        3.0f, 0.5f, 0.5f, 1.0f);

            m_undoStack.pop_back();
        }

    public:
        MoriaCppMod() {
            ModVersion = STR("1.0");
            ModName = STR("MoriaCppMod");
            ModAuthors = STR("johnb");
            ModDescription = STR("C++ HISM removal + throttled replay + world-switch detection");
            Output::send<LogLevel::Warning>(STR("[MoriaCppMod] Loaded v1.0\n"));
        }

        ~MoriaCppMod() override {}

        auto on_unreal_init() -> void override
        {
            Output::send<LogLevel::Warning>(STR("[MoriaCppMod] Unreal initialized.\n"));

            m_saveFilePath = "Mods/MoriaCppMod/removed_instances.txt";
            loadSaveFile();
            probePrintString();

            register_keydown_event(Input::Key::NUM_ZERO, [this]() {
                int pending = pendingCount();
                int applied = static_cast<int>(m_savedRemovals.size()) - pending;
                Output::send<LogLevel::Warning>(
                    STR("[MoriaCppMod] Status: {} saved ({} applied, {} pending), {} undo, {} type rules\n"),
                    m_savedRemovals.size(), applied, pending,
                    m_undoStack.size(), m_typeRemovals.size());
                showOnScreen(L"Status: " + std::to_wstring(m_savedRemovals.size()) + L" saved (" +
                            std::to_wstring(applied) + L" applied, " +
                            std::to_wstring(pending) + L" pending), " +
                            std::to_wstring(m_undoStack.size()) + L" undo", 5.0f);
                showGameMessage(L"[Mod] " + std::to_wstring(applied) + L"/" +
                               std::to_wstring(m_savedRemovals.size()) + L" applied, " +
                               std::to_wstring(pending) + L" pending");
            });

            register_keydown_event(Input::Key::NUM_ONE, [this]() { removeAimed(); });
            register_keydown_event(Input::Key::NUM_TWO, [this]() { undoLast(); });

            register_keydown_event(Input::Key::NUM_THREE, [this]() {
                Output::send<LogLevel::Warning>(STR("[MoriaCppMod] Forcing full replay (throttled)...\n"));
                m_processedComps.clear();
                m_appliedRemovals.assign(m_appliedRemovals.size(), false);
                m_replay = {};  // reset any in-progress replay
                startReplay();
                showOnScreen(L"Replay started (throttled)", 3.0f, 0.0f, 0.8f, 1.0f);
            });

            register_keydown_event(Input::Key::NUM_FOUR, [this]() { inspectAimed(); });

            register_keydown_event(Input::Key::NUM_FIVE, [this]() { testAllDisplayMethods(); });
            register_keydown_event(Input::Key::NUM_SIX, [this]() { removeAllOfType(); });

            m_replayActive = true;
            Output::send<LogLevel::Warning>(
                STR("[MoriaCppMod] v1.0: Num1=remove Num2=undo Num3=replay Num4=inspect Num5=testDisplay Num6=removeAll\n"));
        }

        auto on_update() -> void override
        {
            if (!m_replayActive) return;
            m_frameCounter++;
            m_rescanCounter++;

            // Detect world switch: if character was loaded but disappears, reset for new world
            if (m_characterLoaded && m_frameCounter % 60 == 0) {
                std::vector<UObject*> dwarves;
                UObjectGlobals::FindAllOf(STR("BP_FGKDwarf_C"), dwarves);
                if (dwarves.empty()) {
                    Output::send<LogLevel::Warning>(
                        STR("[MoriaCppMod] Character lost — world unloading, resetting replay state\n"));
                    m_characterLoaded = false;
                    m_initialReplayDone = false;
                    m_processedComps.clear();
                    m_undoStack.clear();
                    m_stuckLogCount = 0;
                    m_rescanCounter = 0;
                    m_chatWidget = nullptr;
                    m_sysMessages = nullptr;
                    m_replay = {};  // stop any active replay
                    // Reset all applied flags so replay re-runs for new world
                    m_appliedRemovals.assign(m_appliedRemovals.size(), false);
                }
            }

            // Wait for player character to load before starting replay
            if (!m_characterLoaded) {
                if (m_frameCounter % 30 == 0) {  // check every ~0.5s
                    std::vector<UObject*> dwarves;
                    UObjectGlobals::FindAllOf(STR("BP_FGKDwarf_C"), dwarves);
                    if (!dwarves.empty()) {
                        m_characterLoaded = true;
                        m_charLoadFrame = m_frameCounter;
                        Output::send<LogLevel::Warning>(
                            STR("[MoriaCppMod] Character loaded at frame {} — waiting 15s before replay\n"),
                            m_frameCounter);
                    }
                }
                return;  // don't do anything until character exists
            }

            int framesSinceChar = m_frameCounter - m_charLoadFrame;

            // Initial replay 15 seconds after character load (~900 frames at 60fps)
            // Extra delay to let streaming settle before modifying instance buffers
            static constexpr int INITIAL_DELAY = 900;
            if (!m_initialReplayDone && framesSinceChar == INITIAL_DELAY) {
                m_initialReplayDone = true;
                if (!m_savedRemovals.empty() || !m_typeRemovals.empty()) {
                    Output::send<LogLevel::Warning>(STR("[MoriaCppMod] Starting initial replay (15s after char load)...\n"));
                    startReplay();
                }
            }

            // Process throttled replay batch (max MAX_HIDES_PER_FRAME per frame)
            if (m_replay.active) {
                processReplayBatch();
            }

            // Check for newly-streamed components every ~3s (after initial replay, when not already replaying)
            if (m_initialReplayDone && !m_replay.active && m_frameCounter % STREAM_CHECK_INTERVAL == 0) {
                checkForNewComponents();
            }

            // Periodic full rescan every ~60s while there are pending removals
            static constexpr int RESCAN_INTERVAL = 3600;  // ~60s at 60fps
            if (m_initialReplayDone && !m_replay.active && m_rescanCounter >= RESCAN_INTERVAL && hasPendingRemovals()) {
                m_rescanCounter = 0;
                int pending = pendingCount();
                Output::send<LogLevel::Warning>(
                    STR("[MoriaCppMod] Periodic rescan ({} pending)...\n"), pending);
                m_processedComps.clear();
                startReplay();
                if (m_stuckLogCount == 0 && pending > 0) {
                    m_stuckLogCount++;
                    Output::send<LogLevel::Warning>(
                        STR("[MoriaCppMod] === Pending entries ({}) ===\n"), pending);
                    for (size_t i = 0; i < m_savedRemovals.size(); i++) {
                        if (m_appliedRemovals[i]) continue;
                        std::wstring meshW(m_savedRemovals[i].meshName.begin(),
                                           m_savedRemovals[i].meshName.end());
                        Output::send<LogLevel::Warning>(
                            STR("[MoriaCppMod]   PENDING [{}]: {} @ ({:.1f},{:.1f},{:.1f})\n"),
                            i, meshW, m_savedRemovals[i].posX,
                            m_savedRemovals[i].posY, m_savedRemovals[i].posZ);
                    }
                }
            }
        }
    };
}

#define MOD_EXPORT __declspec(dllexport)
extern "C" {
    MOD_EXPORT RC::CppUserModBase* start_mod() { return new MoriaMods::MoriaCppMod(); }
    MOD_EXPORT void uninstall_mod(RC::CppUserModBase* mod) { delete mod; }
}
